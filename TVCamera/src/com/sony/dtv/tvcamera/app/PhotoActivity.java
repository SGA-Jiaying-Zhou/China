package com.sony.dtv.tvcamera.app;import android.Manifest;import android.annotation.SuppressLint;import android.app.AlertDialog;import android.content.BroadcastReceiver;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.content.IntentFilter;import android.content.SharedPreferences;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Matrix;import android.graphics.SurfaceTexture;import android.hardware.Camera;import android.hardware.usb.UsbManager;import android.media.AudioManager;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v4.app.ActivityCompat;import android.text.TextUtils;import android.text.format.DateFormat;import android.util.Log;import android.view.KeyEvent;import android.view.TextureView;import android.view.View;import android.view.animation.AlphaAnimation;import android.view.animation.Animation;import android.view.animation.AnimationSet;import android.view.animation.TranslateAnimation;import android.widget.Button;import android.widget.FrameLayout;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import com.sony.dtv.camerarecognition.CameraRecognition;import com.sony.dtv.tvcamera.R;import com.sony.dtv.tvcamera.app.cameracomponent.CameraEncoder;import com.sony.dtv.tvcamera.app.permission.ManageNoncriticalPermissionExtActivity;import com.sony.dtv.tvcamera.app.photosetting.PhotoSettingConstants;import com.sony.dtv.tvcamera.app.receiver.SonyCameraDetachedReceiver;import com.sony.dtv.tvcamera.app.widget.RoundProgressBar;import com.sony.dtv.tvcamera.utils.TVCameraMediaActionSound;import com.sony.dtv.tvcamera.utils.Utils;import java.io.File;import java.util.HashMap;import java.util.LinkedList;@SuppressLint("NewApi")public class PhotoActivity extends ManageNoncriticalPermissionExtActivity implements View.OnClickListener, CameraStatusListener, USBStatusListener,        TextureView.SurfaceTextureListener {    private static final String TAG = "PhotoActivity";    private TextureView mCameraTextureView;    private TextView mCurrentTimeTextView = null;    private RelativeLayout mPrepareImageLayout;    private Button mPhotoCaptureButton = null;    private Button mSettingButton;    private Button mSwitchToCameraButton;    private Button mAlbumButton;    private Button mMirrorButton;    private Button mSaveButton;    private Button mReturnToTVButton;    private FrameLayout mCountDownLayout;    private TextView mCountBackwardsText;    private RoundProgressBar mTimeBar;    private ImageView mBlackView = null;    private static final int LAST_FOCUS_ON_PHOTO_CAPTURE = 0;    private static final int CAMERA_MODE_ON_SETTING = 1;    private static final int CAMERA_MODE_ON_SWITCH_TO_CAMERA = 2;    private static final int CAMERA_MODE_ON_ALBUM = 3;    private static final int CAMERA_MODE_ON_CHANGE_MIRROR = 4;    private int mLastFocus = -1;    private Matrix mTransform;    private float mPivotX;    private final String ALBUM_INTENT = "com.sonyericsson.album.ACTION_MAIN";    LinkedList<String> mUSBList;    private HashMap<String, String> mUSBPath;    String USB_DEVICE_PATH = "/storage/sda1";    String USB_DEVICE_SDCARD = "sdcard";    String USB_DEVICE_FILTER = "/storage/sd";    private USBDeviceBroadcastReceiver mUSBDeviceBroadcastReceiver = null;    private BroadcastReceiver mFinishReceiver = null;    private String mUSBCurrentPath;    private SharedPreferences mSettings;    private SharedPreferences.Editor mEditor;    private CameraEncoder mCameraEncoder = null;    private boolean mIsPreviewStartFlag = false;    private boolean mIsEnterSetting = false;    private boolean mIsCameraAvailable = false;    private boolean mIsUSBAvailable = false;    private boolean mIsSwitchButtonPressed = false;    private boolean mIsHideAnimationStarted = false;    private boolean mIsMirror = false;    private boolean mIsToastCanShown = true;    private Bitmap mPhotoBitmap = null;    private int mProgress = 0;    private int mCount = 0;    private boolean isTakePicture = false;    private boolean mIsLoadingFinished = false;    private TVCameraMediaActionSound mMediaActionSound = null;    private SonyCameraDetachedReceiver mSonyCameraDetachedReceiver;    private boolean mIsCheckStoragePermission = false;    /**     * mHolder Broadcast to receive action form TvAction service     */    BroadcastReceiver mTvActionReceiver = null;    private final Handler mHandler = new Handler();    private final Runnable mUpdateCurrentTimeTask = new Runnable() {        public void run() {            long sysTime = System.currentTimeMillis();            String strTimeFormat = null;            boolean is24HourFormat = DateFormat.is24HourFormat(getApplicationContext());            Log.v(TAG, "is24HourFormat = " + is24HourFormat);            if (is24HourFormat) {                Log.v(TAG, "24 hour");                strTimeFormat = "yyyy/MM/dd(E) HH:mm";            } else {                Log.v(TAG, "12 hour");                strTimeFormat = "yyyy/MM/dd(E) hh:mm";            }            CharSequence sysTimeStr = DateFormat.format(strTimeFormat, sysTime);            if (mCurrentTimeTextView != null) {                mCurrentTimeTextView.setText(sysTimeStr);            }            mHandler.removeCallbacks(mUpdateCurrentTimeTask);            mHandler.postDelayed(mUpdateCurrentTimeTask, 60000);        }    };    private final Runnable mShowFullViewTask = new Runnable() {        public void run() {            Log.d(TAG, "mShowFullViewTask");            mPrepareImageLayout.setVisibility(View.GONE);            setFocus();            setBasicButtonFocusable(true);            Log.d(TAG, "mPrepareImage GONE");        }    };    private final Runnable mSetProgressTask = new Runnable() {        public void run() {            setProgress();        }    };    private final Runnable mShowPicture = new Runnable() {        @Override        public void run() {            ImageView view = (ImageView) findViewById(R.id.photo_view);            view.setImageBitmap(mPhotoBitmap);            mBlackView.setVisibility(View.INVISIBLE);            view.setVisibility(View.VISIBLE);            mReturnToTVButton.setVisibility(View.VISIBLE);            mSaveButton.setVisibility(View.VISIBLE);            mSaveButton.setFocusable(true);            mSaveButton.setFocusableInTouchMode(true);            mSaveButton.requestFocus();            mSaveButton.requestFocusFromTouch();            mPhotoCaptureButton.setVisibility(View.INVISIBLE);            mSettingButton.setVisibility(View.INVISIBLE);            mSwitchToCameraButton.setVisibility(View.INVISIBLE);            mMirrorButton.setVisibility(View.INVISIBLE);            mAlbumButton.setVisibility(View.INVISIBLE);            showActionBar();        }    };    private Camera.PictureCallback mPictureCallback = new Camera.PictureCallback() {        @Override        public void onPictureTaken(byte[] data, Camera camera) {            mPhotoBitmap = BitmapFactory.decodeByteArray(data, 0, data.length);            isTakePicture = false;            Log.d(TAG, "onPictureTaken()!!!");            mHandler.postDelayed(mShowPicture, 500);        }    };    void showActionBar() {        if (mIsHideAnimationStarted) {            mIsHideAnimationStarted = false;            RelativeLayout layout = (RelativeLayout) findViewById(R.id.action_bar);            AnimationSet animationSet = new AnimationSet(true);            Animation translateAnimation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f,                    Animation.RELATIVE_TO_SELF, 0f,                    Animation.RELATIVE_TO_SELF, 1.0f,                    Animation.RELATIVE_TO_SELF, 0.0f);            Animation alphaAnimation = new AlphaAnimation(0, 1);            animationSet.addAnimation(translateAnimation);            animationSet.addAnimation(alphaAnimation);            animationSet.setDuration(300);            layout.startAnimation(animationSet);        }    }    private Camera.ShutterCallback mShutterCallback = new Camera.ShutterCallback() {        @Override        public void onShutter() {            Log.d(TAG, "onShutter()");            mMediaActionSound.playScanKaSha();            mBlackView.setVisibility(View.VISIBLE);        }    };    @Override    protected void onStop() {        Log.i(TAG, "onStop");        super.onStop();        mHandler.removeCallbacks(mSetCameraContentViewTask);        if (null != mUSBDeviceBroadcastReceiver) {            unregisterReceiver(mUSBDeviceBroadcastReceiver);            mUSBDeviceBroadcastReceiver = null;        }        stopCapturing();        if (null != mSonyCameraDetachedReceiver) {            unregisterReceiver(mSonyCameraDetachedReceiver);            mSonyCameraDetachedReceiver = null;        }        releasePreview();        if (!mIsToastCanShown) {            mIsToastCanShown = true;            mHandler.removeCallbacks(mToastTask);        }        if (null != mPhotoBitmap) {            mPhotoBitmap.recycle();            mPhotoBitmap = null;        }        mHandler.removeCallbacks(mUpdateCurrentTimeTask);        Log.i(TAG, "mIsEnterSetting = " + mIsEnterSetting);        if (!mIsEnterSetting && !mIsCheckStoragePermission) {            finish();        } else {            mIsEnterSetting = false;            mIsCheckStoragePermission = false;        }    }    Runnable mToastTask = new Runnable() {        @Override        public void run() {            mIsToastCanShown = true;        }    };    @Override    public boolean dispatchKeyEvent(KeyEvent event) {        // TODO Auto-generated method stub        Log.v(TAG, "keyEvent:" + event);        switch (event.getKeyCode()) {            case KeyEvent.KEYCODE_DPAD_CENTER:                if (event.getAction() == KeyEvent.ACTION_DOWN) {                    if ((mPhotoCaptureButton != null) && (mPhotoCaptureButton.hasFocus())) {                        if (mUSBList.size() == 0) {                            if (mIsToastCanShown) {                                Toast.makeText(this, R.string.no_usb_photo, Toast.LENGTH_SHORT).show();                            }                            AudioManager manager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);                            manager.playSoundEffect(AudioManager.FX_KEYPRESS_INVALID);                        } else if (mUSBList.size() >= 1 && Utils.getMemoryCapacity(mUSBCurrentPath) <= 3) {                            if (mIsToastCanShown) {                                Toast.makeText(this, R.string.memory_little_tip_photo, Toast.LENGTH_SHORT).show();                            }                            AudioManager manager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);                            manager.playSoundEffect(AudioManager.FX_KEYPRESS_INVALID);                        }                        if (mIsToastCanShown) {                            mIsToastCanShown = false;                            mHandler.postDelayed(mToastTask, 5000);                        }                    }                }                break;            case KeyEvent.KEYCODE_BACK:                if (event.getAction() == KeyEvent.ACTION_DOWN) {                    if ((mReturnToTVButton != null) && (mReturnToTVButton.getVisibility() == View.VISIBLE)) {                        returnToTV();                        return true;                    } else if ((mCountDownLayout != null) && (mCountDownLayout.getVisibility() == View.VISIBLE)) {                        mCountDownLayout.setVisibility(View.INVISIBLE);                        cancelCountDown();                        updateCaptureButtonStatus();                        return true;                    } else if ((mBlackView != null) && (mBlackView.getVisibility() == View.VISIBLE || isTakePicture)) {                        return true;                    }                }                break;            default:        }        return super.dispatchKeyEvent(event);    }    private final Runnable mSetCameraContentViewTask = new Runnable() {        public void run() {            setCameraContentView();        }    };    private void setCameraContentView() {        mCameraEncoder = new CameraEncoder(this, TAG);        updateCameraPictureSize();        setContentView(R.layout.camera_full_photo);        mPrepareImageLayout = (RelativeLayout) findViewById(R.id.prepare_image);        init();        mCurrentTimeTextView = (TextView) findViewById(R.id.current_time);        mHandler.removeCallbacks(mUpdateCurrentTimeTask);        mHandler.postDelayed(mUpdateCurrentTimeTask, 0);        mHandler.removeCallbacks(mShowFullViewTask);        mHandler.postDelayed(mShowFullViewTask, 3000);        getUsbPath(null);        IntentFilter usbChangeFilter = new IntentFilter();        usbChangeFilter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);        mSonyCameraDetachedReceiver = new SonyCameraDetachedReceiver(mCameraEncoder, this);        registerReceiver(mSonyCameraDetachedReceiver, usbChangeFilter);        mIsLoadingFinished = true;    }    private String[] mCriticalPermissions = new String[]{            Manifest.permission.CAMERA,            Manifest.permission.RECORD_AUDIO,    };    private boolean isPermissionDenied(String permission) {        return ActivityCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_DENIED;    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.i(TAG, "onCreate");        for (String permission : mCriticalPermissions) {            if (isPermissionDenied(permission)) {                finish();                return;            }        }        if (TVCameraApp.isTerminateKeyPress()) {            finish();            return;        }        Intent intent = getIntent();        boolean isFirstLaunchIntent = intent.getBooleanExtra("isLaunchIntent", false);        Utils.setIsFirstLaunch(isFirstLaunchIntent);        Log.i(TAG, "isFirstLaunchIntent = " + isFirstLaunchIntent);        if (isFirstLaunchIntent) {            Utils.sendStateChangeIntent(true);        }        TVCameraApp.registerTerminateKeyReceiver();        mIsEnterSetting = false;        mIsCheckStoragePermission = false;        mIsCameraAvailable = false;        mIsUSBAvailable = false;        mIsSwitchButtonPressed = false;        setContentView(R.layout.activity_pre_load);        // Register action from Tv Action        registerTvActionReceiver();        mLastFocus = LAST_FOCUS_ON_PHOTO_CAPTURE;        int lastFocusOnSwitchToPhoto = intent.getIntExtra("FocusOnSwitchToPhoto", 0);        if (lastFocusOnSwitchToPhoto != 0) {            mLastFocus = CAMERA_MODE_ON_SWITCH_TO_CAMERA;        }        mUSBList = new LinkedList<>();        mUSBPath = new HashMap<>();        mFinishReceiver = new BroadcastReceiver() {            @Override            public void onReceive(Context context, Intent intent) {                // TODO Auto-generated method stub                if (intent.getAction().equals(Intent.ACTION_LOCALE_CHANGED)) {                    finish();                }            }        };        IntentFilter locale_changed_filter = new IntentFilter(Intent.ACTION_LOCALE_CHANGED);        registerReceiver(mFinishReceiver, locale_changed_filter);        SharedPreferences sp = getSharedPreferences("tvcameramode", Context.MODE_PRIVATE);        mEditor = sp.edit();        mEditor.putInt("tvcameramodevalue", Utils.PHOTO_MODE);        mEditor.commit();        mMediaActionSound = new TVCameraMediaActionSound(this);        mIsLoadingFinished = false;        if (isFirstLaunchIntent) {            mHandler.postDelayed(mSetCameraContentViewTask, 5000);        } else {            mHandler.post(mSetCameraContentViewTask);        }    }    private void registerTvActionReceiver() {        IntentFilter tvActionfilters = new IntentFilter();        tvActionfilters.addAction(Utils.INTENT_ACTION_CLOSE_APP);        mTvActionReceiver = new BroadcastReceiver() {            @Override            public void onReceive(Context context, Intent intent) {                String action = intent.getAction();                Log.d(TAG, "action: " + action);                if (Utils.INTENT_ACTION_CLOSE_APP.equals(action)) {                    unregisterTvActionReceiver();                    finish();                }            }        };        try {            registerReceiver(mTvActionReceiver, tvActionfilters);        } catch (Exception ex) {            Log.e(TAG, "Exception: " + ex);        }    }    private void unregisterTvActionReceiver() {        if (null != mTvActionReceiver) {            unregisterReceiver(mTvActionReceiver);            mTvActionReceiver = null;        }    }    @Override    protected void onPause() {        super.onPause();        Log.i(TAG, "onPause!");    }    @Override    protected void onResume() {        Log.i(TAG, "onResume!");        super.onResume();    }    @Override    protected void onDestroy() {        Log.i(TAG, "onDestroy");        super.onDestroy();        removeCallbackTask();        if (!mIsToastCanShown) {            mIsToastCanShown = true;            mHandler.removeCallbacks(mToastTask);        }        unregisterTvActionReceiver();        if (null != mFinishReceiver) {            unregisterReceiver(mFinishReceiver);            mFinishReceiver = null;        }        if (null != mMediaActionSound) {            mMediaActionSound.release();            mMediaActionSound = null;        }        if (null != mPhotoBitmap) {            mPhotoBitmap.recycle();            mPhotoBitmap = null;        }        if (!mIsSwitchButtonPressed) {            Utils.sendStateChangeIntent(false);        }    }    @Override    protected void onStart() {        // TODO Auto-generated method stub        super.onStart();        Log.i(TAG, "onStart");        getUsbPath(null);        checkStorage();        if (mUSBList.size() == 0) {            Toast.makeText(this, R.string.no_usb_photo, Toast.LENGTH_LONG).show();        }        updateCameraPictureSize();        IntentFilter filter = new IntentFilter(Intent.ACTION_MEDIA_MOUNTED);        filter.addAction(Intent.ACTION_MEDIA_EJECT);        filter.addDataScheme("file");        mUSBDeviceBroadcastReceiver = new USBDeviceBroadcastReceiver();        registerReceiver(mUSBDeviceBroadcastReceiver, filter);        if ((mIsLoadingFinished) && (null == mSonyCameraDetachedReceiver)) {            IntentFilter usbChangeFilter = new IntentFilter();            usbChangeFilter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);            mSonyCameraDetachedReceiver = new SonyCameraDetachedReceiver(mCameraEncoder, this);            registerReceiver(mSonyCameraDetachedReceiver, usbChangeFilter);        }        mHandler.removeCallbacks(mUpdateCurrentTimeTask);        mHandler.postDelayed(mUpdateCurrentTimeTask, 0);        mIsHideAnimationStarted = false;    }    private void removeCallbackTask() {        mHandler.removeCallbacks(mSetCameraContentViewTask);        mHandler.removeCallbacks(mUpdateCurrentTimeTask);        mHandler.removeCallbacks(mShowFullViewTask);        mHandler.removeCallbacks(mSetProgressTask);        mHandler.removeCallbacks(mToastTask);    }    protected void init() {        mCameraTextureView = (TextureView) findViewById(R.id.camera_preview);        mPhotoCaptureButton = (Button) findViewById(R.id.photo_capture);        mSettingButton = (Button) findViewById(R.id.setting);        mSwitchToCameraButton = (Button) findViewById(R.id.to_camera);        mAlbumButton = (Button) findViewById(R.id.album);        mMirrorButton = (Button) findViewById(R.id.mirror);        mSaveButton = (Button) findViewById(R.id.save);        mReturnToTVButton = (Button) findViewById(R.id.return_to_tv);        mCurrentTimeTextView = (TextView) findViewById(R.id.current_time);        mCountBackwardsText = (TextView) findViewById(R.id.count_backwards);        mCountDownLayout = (FrameLayout) findViewById(R.id.count_down_root);        mTimeBar = (RoundProgressBar) findViewById(R.id.time_bar);        mBlackView = (ImageView) findViewById(R.id.photo_view_black);        mPhotoCaptureButton.setOnClickListener(this);        mSwitchToCameraButton.setOnClickListener(this);        mAlbumButton.setOnClickListener(this);        mSettingButton.setOnClickListener(this);        mCameraTextureView.setSurfaceTextureListener(this);        mMirrorButton.setOnClickListener(this);        mSaveButton.setOnClickListener(this);        mReturnToTVButton.setOnClickListener(this);        mSettingButton.setOnFocusChangeListener(mOnFocusChangeListener);        mMirrorButton.setOnFocusChangeListener(mOnFocusChangeListener);        mSwitchToCameraButton.setOnFocusChangeListener(mOnFocusChangeListener);        mAlbumButton.setOnFocusChangeListener(mOnFocusChangeListener);        mReturnToTVButton.setOnFocusChangeListener(mOnFocusChangeListener);        mSaveButton.setOnFocusChangeListener(mOnFocusChangeListener);        setCameraCaptureButtonStatus();    }    private void setProgress() {        if (mProgress == 0) {            switch (mCount) {                case 0:                    mCountBackwardsText.setText("3");                    mCountDownLayout.setVisibility(View.VISIBLE);                    mCountBackwardsText.setVisibility(View.VISIBLE);                    break;                case 1:                    mCountBackwardsText.setText("2");                    break;                case 2:                    mCountBackwardsText.setText("1");                    break;                default:                    isTakePicture = true;                    mCameraEncoder.getCurrentCamera().enableShutterSound(false);                    mCameraEncoder.getCurrentCamera().takePicture(mShutterCallback, null, mPictureCallback);                    mCountDownLayout.setVisibility(View.INVISIBLE);                    mIsPreviewStartFlag = false;                    return;            }            mCountBackwardsText.setScaleX(0.9f);            mCountBackwardsText.setScaleY(0.9f);            mCountBackwardsText.animate().scaleX(1.0f).scaleY(1.0f).setDuration(200).start();            mMediaActionSound.playSelfTimer();        }        if (mCount < 3) {            if (mProgress < 99) {                mProgress += 3;            } else if (mProgress == 99) {                mProgress = 0;                mCount++;                mHandler.removeCallbacks(mSetProgressTask);                mHandler.postDelayed(mSetProgressTask, 340);                return;            }            mTimeBar.setProgress(mProgress);            mHandler.removeCallbacks(mSetProgressTask);            mHandler.postDelayed(mSetProgressTask, 20);        }    }    private void setFocus() {        Button defaultFocusedButton = mPhotoCaptureButton;        switch (mLastFocus) {            case LAST_FOCUS_ON_PHOTO_CAPTURE:                if (mPhotoCaptureButton.isEnabled()) {                    if (mPhotoCaptureButton.hasFocus()) {                        mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused));                    } else {                        mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal));                    }                } else {                    if (mPhotoCaptureButton.hasFocus()) {                        mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused_disable));                    } else {                        mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal_disable));                    }                }                break;            case CAMERA_MODE_ON_SETTING:                defaultFocusedButton = mSettingButton;                break;            case CAMERA_MODE_ON_SWITCH_TO_CAMERA:                defaultFocusedButton = mSwitchToCameraButton;                break;            case CAMERA_MODE_ON_ALBUM:                defaultFocusedButton = mAlbumButton;                break;            case CAMERA_MODE_ON_CHANGE_MIRROR:                defaultFocusedButton = mMirrorButton;                break;            default:                break;        }        defaultFocusedButton.setFocusable(true);        defaultFocusedButton.setFocusableInTouchMode(true);        defaultFocusedButton.requestFocus();        defaultFocusedButton.requestFocusFromTouch();        if (mLastFocus == LAST_FOCUS_ON_PHOTO_CAPTURE) {            if (mPhotoCaptureButton.isEnabled()) {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused));            } else {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused_disable));            }        } else {            if (mPhotoCaptureButton.isEnabled()) {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal));            } else {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal_disable));            }        }    }    private void stopPreview() {        if (mIsPreviewStartFlag) {            Message msg = mCameraEncoder.obtainMessage(CameraEncoder.CAMERA_ONLY_STOP_PREVIEW);            mCameraEncoder.sendMessage(msg);            mIsPreviewStartFlag = false;        }    }    private void releasePreview() {        if (mIsPreviewStartFlag) {            Message msg = mCameraEncoder.obtainMessage(CameraEncoder.CAMERA_ONLY_RELEASE_PREVIEW);            mCameraEncoder.sendMessage(msg);            mIsPreviewStartFlag = false;        }    }    public void stopCapturing() {        if (mCurrentTimeTextView == null) {            return;        }        if (mCurrentTimeTextView.getVisibility() == View.INVISIBLE) {            mHandler.removeCallbacks(mSetProgressTask);            mReturnToTVButton.setVisibility(View.INVISIBLE);            mSaveButton.setVisibility(View.INVISIBLE);            setBasicButtonFocusable(true);            mPhotoCaptureButton.setVisibility(View.VISIBLE);            mSettingButton.setVisibility(View.VISIBLE);            mSwitchToCameraButton.setVisibility(View.VISIBLE);            mMirrorButton.setVisibility(View.VISIBLE);            mAlbumButton.setVisibility(View.VISIBLE);            mCurrentTimeTextView.setVisibility(View.VISIBLE);            if (Utils.getMemoryCapacity(mUSBCurrentPath) <= 3) {                setUSBStatus(false);            }        }    }    void cancelCountDown() {        if (mCurrentTimeTextView.getVisibility() == View.INVISIBLE) {            mHandler.removeCallbacks(mSetProgressTask);            showActionBar();            setBasicButtonFocusable(true);            mPhotoCaptureButton.setVisibility(View.VISIBLE);            mSettingButton.setVisibility(View.VISIBLE);            mSwitchToCameraButton.setVisibility(View.VISIBLE);            mMirrorButton.setVisibility(View.VISIBLE);            mAlbumButton.setVisibility(View.VISIBLE);            mCurrentTimeTextView.setVisibility(View.VISIBLE);            if (Utils.getMemoryCapacity(mUSBCurrentPath) <= 3) {                setUSBStatus(false);            }        }    }    private void setBasicButtonFocusable(boolean isFocusable) {        Log.d(TAG, "setBasicButtonFocusable isFocusable = " + isFocusable);        mPhotoCaptureButton.setFocusable(isFocusable);        mSettingButton.setFocusable(isFocusable);        mSwitchToCameraButton.setFocusable(isFocusable);        mMirrorButton.setFocusable(isFocusable);        mAlbumButton.setFocusable(isFocusable);    }    private void Mirror() {        mTransform.postScale(-1, 1, mPivotX, 0);        mCameraTextureView.setTransform(mTransform);    }    private void startPreview() {        if (!mIsPreviewStartFlag) {            Message msg = mCameraEncoder.obtainMessage(CameraEncoder.CAMERA_ONLY_START_PREVIEW_1080);            mCameraEncoder.sendMessage(msg);            mIsPreviewStartFlag = true;            mTransform = new Matrix();            mPivotX = mCameraTextureView.getWidth() / 2;            boolean isCameraInsert = Utils.checkCameraInsert(getApplicationContext());            if (!isCameraInsert) {                return;            }            SharedPreferences mirrorPreferences = getSharedPreferences("mirror", 0);            if (Utils.needMirror(this)) {                mIsMirror = true;            } else {                mIsMirror = mirrorPreferences.getBoolean("mirrorflags", false);            }            if (mIsMirror) {                Mirror();            }        }    }    private void returnToTV() {        stopCapturing();        startPreview();        mHandler.postDelayed(new Runnable() {            @Override            public void run() {                ImageView view = (ImageView) findViewById(R.id.photo_view);                view.setVisibility(View.INVISIBLE);            }        }, 500);        if (null != mPhotoBitmap) {            mPhotoBitmap.recycle();            mPhotoBitmap = null;        }    }    void hideActionBar() {        mIsHideAnimationStarted = true;        RelativeLayout layout = (RelativeLayout) findViewById(R.id.action_bar);        AnimationSet animationSet = new AnimationSet(true);        Animation translateAnimation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f,                Animation.RELATIVE_TO_SELF, 0f,                Animation.RELATIVE_TO_SELF, 0.0f,                Animation.RELATIVE_TO_SELF, 1.0f);        Animation alphaAnimation = new AlphaAnimation(1, 0);        animationSet.addAnimation(translateAnimation);        animationSet.addAnimation(alphaAnimation);        animationSet.setFillAfter(true);        animationSet.setDuration(300);        layout.startAnimation(animationSet);    }    @Override    public void onClick(View v) {        switch (v.getId()) {            case R.id.photo_capture:                Log.i(TAG, "camera capture be pressed!");                checkStoragePermission();                break;            case R.id.setting:                Log.i(TAG, "setting be pressed!");                releasePreview();                mIsEnterSetting = true;                Intent startSetting = new Intent(getApplicationContext(),                        PhotoSettingActivity.class);                startActivity(startSetting);                break;            case R.id.album:                Log.i(TAG, "album be pressed!");                stopPreview();                Intent startMain = new Intent(ALBUM_INTENT);                startMain.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);                startActivity(startMain);                break;            case R.id.to_camera:                releasePreview();                Intent myIntent = new Intent().setClass(this, MirrorActivity.class);                myIntent.putExtra("FocusOnSwitchToCamera", 1);                myIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK                        | Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);                startActivity(myIntent);                mIsSwitchButtonPressed = true;                finish();                break;            case R.id.mirror:                SharedPreferences mirrorPreferences = getSharedPreferences("mirror", 0);                SharedPreferences.Editor mirrorEditor = mirrorPreferences.edit();                Mirror();                mIsMirror = !mIsMirror;                mirrorEditor.putBoolean("mirrorflags", mIsMirror);                mirrorEditor.commit();                break;            case R.id.return_to_tv:                Log.i(TAG, "return_to_tv be pressed!");                returnToTV();                break;            case R.id.save:                Log.i(TAG, "save be pressed!");                boolean needCheck = Utils.saveImage(mPhotoBitmap, CameraRecognition.CAPTURE_TYPE_ONE_SHOT_WITHOUT_ANALYSIS, PhotoActivity.this);                if (needCheck) {                    checkMemoryCapacity();                }                returnToTV();                break;        }    }    private void updateCameraPictureSize() {        if (mCameraEncoder == null) return;        int captureWidth = 0;        int captureHeight = 0;        SharedPreferences smileShutter = getSharedPreferences(PhotoSettingConstants.SP_NAME, Context.MODE_PRIVATE);        String PictureSizeKey = smileShutter.getString(PhotoSettingConstants.PictureSizeKey, getString(R.string.picture_size_defValue));        if (PictureSizeKey.equals("1920 x 1080")) {            captureWidth = Utils.CAMERA_SIZE_1080P_WIDTH;            captureHeight = Utils.CAMERA_SIZE_1080P_HEIGHT;        } else if (PictureSizeKey.equals("1280 x 720")) {            captureWidth = Utils.CAMERA_SIZE_720P_WIDTH;            captureHeight = Utils.CAMERA_SIZE_720P_HEIGHT;        } else {            captureWidth = Utils.CAMERA_SIZE_360P_WIDTH;            captureHeight = Utils.CAMERA_SIZE_360P_HEIGHT;        }        mCameraEncoder.setCameraPictureSize(captureWidth, captureHeight);    }    // TextureView class    @Override    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width,                                          int height) {        Log.v(TAG, "onSurfaceTextureAvailable");        boolean isFirstLaunch = Utils.isFirstLaunch();        Log.d(TAG, "isFirstLaunch = " + isFirstLaunch);        if (isFirstLaunch) {            int type = Utils.getCameraSupportType();            if (type == Utils.CAMERA_NOT_SUPPORT) {                Utils.CameraSupportError(getApplication());                return;            }        }        mCameraEncoder.setSurfaceTexture(surface);        startPreview();    }    @Override    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width,                                            int height) {    }    @Override    public void onSurfaceTextureUpdated(SurfaceTexture surface) {    }    @Override    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {        mCameraEncoder.setSurfaceTexture(null);        return false;    }    /* get mounted storage space */    public void getUsbPath(String default_usb) {        int preUSBListSize = mUSBList.size();        //mUSBList.clear();        if (default_usb == null || default_usb.equalsIgnoreCase(" ")) {            default_usb = USB_DEVICE_SDCARD;        }        mUSBList = Utils.getUSBPathList(mUSBList, getApplicationContext());        mSettings = getSharedPreferences("usb", 0);        mEditor = mSettings.edit();        mEditor.putInt("usb_count", mUSBList.size());        mEditor.commit();        if (mUSBList.size() > 0) {            if (mUSBList.indexOf(default_usb) >= 0) {                USB_DEVICE_PATH = default_usb;            } else {                USB_DEVICE_PATH = mUSBList.get(0);            }            mUSBPath.clear();            for (int i = 0; i < mUSBList.size(); i++) {                mUSBPath.put("USB" + (i + 1), mUSBList.get(i));            }            mSettings = getSharedPreferences(PhotoSettingConstants.SP_NAME, 0);            String keyDestination = mSettings.getString(PhotoSettingConstants.DestinationKey, "");            int curUSBListSize = mUSBList.size();            if (TextUtils.equals(keyDestination, "") || curUSBListSize == 1 || (preUSBListSize - curUSBListSize) == 1) {                keyDestination = "USB1";                mEditor = mSettings.edit();                mEditor.putString(PhotoSettingConstants.DestinationKey, keyDestination);                mEditor.commit();            }            SharedPreferences USBPath = getSharedPreferences("usb", 0);            mEditor = USBPath.edit();            mEditor.putString("old_usb_current_photo_path", mUSBCurrentPath);            mEditor.commit();            mUSBCurrentPath = mUSBPath.get(keyDestination);            mEditor.putString("usb_current_photo_path", mUSBCurrentPath);            mEditor.commit();        } else {            SharedPreferences USBPath = getSharedPreferences("usb", 0);            USBPath.edit().clear().commit();            mUSBCurrentPath = null;        }        Log.d(TAG, "usbRoot " + USB_DEVICE_PATH);    }    @Override    protected void onStoragePermissionGranted() {        Log.d(TAG, "onStoragePermissionGranted()");        checkStorage();        if (!mIsCameraAvailable || !mIsUSBAvailable) return;        setBasicButtonFocusable(false);        hideActionBar();        mCurrentTimeTextView.setVisibility(View.INVISIBLE);        mCount = 0;        mProgress = 0;        mTimeBar.setProgress(mProgress);        mTimeBar.setVisibility(View.VISIBLE);        mHandler.removeCallbacks(mSetProgressTask);        mHandler.postDelayed(mSetProgressTask, 500);    }    @Override    protected void onStoragePermissionDenied() {        Log.d(TAG, "onStoragePermissionDenied()");        checkStorage();    }    @Override    protected void onBeforeStartPromptActivity() {        mIsCheckStoragePermission = true;        setCameraCaptureButtonStatus(false);    }    @Override    protected String getName() {        return getString(R.string.photo);    }    private class USBDeviceBroadcastReceiver extends BroadcastReceiver {        boolean bIsNeedStorageCheck = false;        @Override        public void onReceive(final Context context, Intent intent) {            // TODO Auto-generated method stub            String action = intent.getAction();            Log.d(TAG, "action..." + action);            String action_path = intent.getData().getPath();            Log.d(TAG, "action_path..." + action_path);            String preUSBCurrentPath = mUSBCurrentPath;            getUsbPath(USB_DEVICE_PATH);            bIsNeedStorageCheck = !TextUtils.equals(mUSBCurrentPath, preUSBCurrentPath);            if (action.equalsIgnoreCase(Intent.ACTION_MEDIA_EJECT)) {                if (bIsNeedStorageCheck) {                    Toast.makeText(context, context.getString(R.string.u_disk_pulled_out),                            Toast.LENGTH_SHORT).show();                    checkStorage();                }                if (!mIsToastCanShown) {                    mIsToastCanShown = true;                    mHandler.removeCallbacks(mToastTask);                }            } else if (action.equalsIgnoreCase(Intent.ACTION_MEDIA_MOUNTED)) {                if (bIsNeedStorageCheck) {                    checkStorage();                }            }        }    }    public void checkMemoryCapacity() {        if (Utils.getMemoryCapacity(mUSBCurrentPath) <= 3) {            new AlertDialog.Builder(this, AlertDialog.THEME_DEVICE_DEFAULT_DARK).setTitle(R.string.dialog_title)                    .setMessage(R.string.memory_little_photo)                    .setPositiveButton(R.string.dialog_ok, new DialogInterface.OnClickListener() {                        @Override                        public void onClick(DialogInterface dialog, int which) {                            Log.d(TAG, "Alert insert camera Dialog!");                        }                    }).show();        }    }    private void checkStorage() {        File USBStorage = null;        if (mUSBCurrentPath != null) {            USBStorage = new File(mUSBCurrentPath);        }        if (mUSBList.size() == 0 || USBStorage == null) {            setUSBStatus(false);        } else if (!isStoragePermissionDenied() && ((!USBStorage.canWrite()) || (!Utils.checkUsbWritablity(mUSBCurrentPath)))) {            setUSBStatus(false);            Toast.makeText(this, R.string.read_only, Toast.LENGTH_SHORT).show();        } else if (!isStoragePermissionDenied() && (Utils.getMemoryCapacity(mUSBCurrentPath) <= 3)) {            setUSBStatus(false);            Toast.makeText(this, R.string.memory_little_tip_photo, Toast.LENGTH_SHORT).show();        } else {            setUSBStatus(true);        }    }    private void setCameraCaptureButtonStatus() {        if (mPhotoCaptureButton == null) {            return;        }        if ((mIsCameraAvailable) && (mIsUSBAvailable)) {            mPhotoCaptureButton.setEnabled(true);            if (mPhotoCaptureButton.hasFocus()) {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused));            } else {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal));            }        } else {            mPhotoCaptureButton.setEnabled(false);            if (mPhotoCaptureButton.hasFocus()) {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused_disable));            } else {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal_disable));            }        }    }    private void setCameraCaptureButtonStatus(boolean enable) {        if (mPhotoCaptureButton == null) {            return;        }        mPhotoCaptureButton.setEnabled(enable);        if (enable) {            if (mPhotoCaptureButton.hasFocus()) {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused));            } else {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal));            }        } else {            if (mPhotoCaptureButton.hasFocus()) {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused_disable));            } else {                mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal_disable));            }        }    }    View.OnFocusChangeListener mOnFocusChangeListener = new View.OnFocusChangeListener() {        @Override        public void onFocusChange(View v, boolean hasFocus) {            if ((mReturnToTVButton.getVisibility() == View.VISIBLE)                    && (mSaveButton.getVisibility() == View.VISIBLE)) {                if (mReturnToTVButton.hasFocus()) {                    mReturnToTVButton.setTextColor(getResources().getColor(R.color.return_to_tv_text_focused));                    mSaveButton.setTextColor(getResources().getColor(R.color.save_text_normal));                } else if (mSaveButton.hasFocus()) {                    mReturnToTVButton.setTextColor(getResources().getColor(R.color.return_to_tv_text_normal));                    mSaveButton.setTextColor(getResources().getColor(R.color.save_text_focused));                }                return;            }            if (mPhotoCaptureButton.isEnabled()) {                if (mPhotoCaptureButton.hasFocus()) {                    mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused));                    return;                } else {                    mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal));                }            } else {                if (mPhotoCaptureButton.hasFocus()) {                    mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_focused_disable));                    return;                } else {                    mPhotoCaptureButton.setTextColor(getResources().getColor(R.color.shoot_text_normal_disable));                }            }            if (hasFocus) {                v.setScaleX(0.8f);                v.setScaleY(0.8f);                v.animate().scaleX(1.0f).scaleY(1.0f).setDuration(200).start();            }        }    };    public void setUSBStatus(boolean isUSBAvailable) {        mIsUSBAvailable = isUSBAvailable;        updateCaptureButtonStatus();    }    public void updateCaptureButtonStatus() {        if (mIsCameraAvailable && mIsUSBAvailable) {            setCameraCaptureButtonStatus(true);        } else {            setCameraCaptureButtonStatus(false);        }    }    @Override    public void notifyCameraStatus(boolean isCameraAvailable) {        mIsCameraAvailable = isCameraAvailable;        updateCaptureButtonStatus();        if (!mIsCameraAvailable) {            stopCapturing();        }    }    @Override    public void notifyUSBStatus(boolean isUSBAvailable) {        if (isUSBAvailable == false) {            mSettingButton.setFocusable(true);            mSettingButton.setEnabled(true);            mSwitchToCameraButton.setFocusable(true);            mSwitchToCameraButton.setEnabled(true);            mAlbumButton.setFocusable(true);            mAlbumButton.setEnabled(true);            setUSBStatus(false);        }    }}